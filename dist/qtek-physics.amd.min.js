define("qtek-physics/qtek-physics.amd",[],function(){console.log("Loaded qtek physics module"),console.log("Author : https://github.com/pissang/")}),define("qtek-physics",["qtek-physics/qtek-physics.amd"],function(a){return a}),define("qtek-physics/Buffer",["require"],function(){var a=function(){this._data=[],this._offset=0};return a.prototype.set=function(a,b){this._data[a]=b},a.prototype.setOffset=function(a){this._offset=a},a.prototype.toFloat32Array=function(){return this._data.length=this._offset,new Float32Array(this._data)},a.prototype.reset=function(){this._data=[],this._offset=0},a.prototype.packScalar=function(a){this._data[this._offset++]=a},a.prototype.packVector2=function(a){this._data[this._offset++]=a._array[0],this._data[this._offset++]=a._array[1]},a.prototype.packVector3=function(a){this._data[this._offset++]=a._array[0],this._data[this._offset++]=a._array[1],this._data[this._offset++]=a._array[2]},a.prototype.packVector4=function(a){this._data[this._offset++]=a._array[0],this._data[this._offset++]=a._array[1],this._data[this._offset++]=a._array[2],this._data[this._offset++]=a._array[3]},a.prototype.packArray=function(a){for(var b=0;b<a.length;b++)this._data[this._offset++]=a[b]},a.prototype.packValues=function(){this.packArray(arguments)},a}),define("qtek-physics/Collider",["require","qtek/core/Base"],function(a){var b=a("qtek/core/Base"),c=b.derive({name:"",collisionObject:null,sceneNode:null,physicsMaterial:null,isKinematic:!1,isStatic:!1,isGhostObject:!1,group:1,collisionMask:1,_dirty:!0,_collisionHasCallback:!1},{on:function(a,c,d){b.prototype.on.call(this,a,c,d),this._collisionHasCallback=!0,this._dirty=!0},off:function(a,c){b.prototype.off.call(this,a,c)},hasCollisionCallback:function(){return this._collisionHasCallback}});return c.events=["collision"],c}),define("qtek-physics/ContactPoint",["require","qtek/math/Vector3"],function(){var a=require("qtek/math/Vector3"),b=function(){this.thisPoint=new a,this.otherPoint=new a,this.otherCollider=null,this.thisCollider=null,this.normal=new a};return b}),define("qtek-physics/AmmoEngineConfig.js",[],function(){return"'use strict';\n\n// Data format\n// Command are transferred in batches\n// ncmd - [cmd chunk][cmd chunk]...\n// Add rigid body :\n//      ------header------ \n//      cmdtype(1)\n//      idx(1)\n//      32 bit mask(1)\n//          But because it is stored in Float, it can only use at most 24 bit (TODO)\n//      -------body-------\n//      collision flag(1)\n//      ...\n//      collision shape guid(1)\n//      shape type(1)\n//      ...\n// Remove rigid body:\n//      cmdtype(1)\n//      idx(1)\n//      \n// Mod rigid body :\n//      ------header------\n//      cmdtype(1)\n//      idx(1)\n//      32 bit mask(1)\n//      -------body-------\n//      ...\n//      \n// Step\n//      cmdtype(1)\n//      timeStep(1)\n//      maxSubSteps(1)\n//      fixedTimeStep(1)\n\nthis.CMD_ADD_COLLIDER = 1;\nthis.CMD_REMOVE_COLLIDER = 2;\nthis.CMD_MOD_COLLIDER = 3;\nthis.CMD_SYNC_MOTION_STATE = 4;\nthis.CMD_STEP_TIME = 5;\nthis.CMD_COLLISION_CALLBACK = 6;\n\nthis.CMD_SYNC_INERTIA_TENSOR = 7;\n\n// Step\nthis.CMD_STEP = 10;\n// Ray test\nthis.CMD_RAYTEST_CLOSEST = 11;\nthis.CMD_RAYTEST_ALL = 12;\n\n// Shape types\nthis.SHAPE_BOX = 0;\nthis.SHAPE_SPHERE = 1;\nthis.SHAPE_CYLINDER = 2;\nthis.SHAPE_CONE = 3;\nthis.SHAPE_CAPSULE = 4;\nthis.SHAPE_CONVEX_TRIANGLE_MESH = 5;\nthis.SHAPE_CONVEX_HULL = 6;\nthis.SHAPE_STATIC_PLANE = 7;\nthis.SHAPE_BVH_TRIANGLE_MESH = 8;\nthis.SHAPE_COMPOUND = 9;\n\n// Rigid Body properties and bit mask\n// 1. Property name\n// 2. Property size\n// 3. Mod bit mask, to check if part of rigid body needs update\nthis.RIGID_BODY_PROPS = [\n    ['linearVelocity', 3, 0x1],\n    ['angularVelocity', 3, 0x2],\n    ['linearFactor', 3, 0x4],\n    ['angularFactor', 3, 0x8],\n    ['centerOfMass', 3, 0x10],\n    ['localInertia', 3, 0x20],\n    ['massAndDamping', 3, 0x40],\n    ['totalForce', 3, 0x80],\n    ['totalTorque', 3, 0x100]\n];\n\nthis.RIGID_BODY_PROP_MOD_BIT = {};\nthis.RIGID_BODY_PROPS.forEach(function(item) {\n    this.RIGID_BODY_PROP_MOD_BIT[item[0]] = item[2];\n}, this);\n\nthis.SHAPE_MOD_BIT = 0x200;\nthis.MATERIAL_MOD_BIT = 0x400;\nthis.COLLISION_FLAG_MOD_BIT = 0x800;\n\nthis.MOTION_STATE_MOD_BIT = 0x1000;\n\nthis.MATERIAL_PROPS = [\n    ['friction', 1],\n    ['bounciness', 1],\n];\n\n// Collision Flags\nthis.COLLISION_FLAG_STATIC = 0x1;\nthis.COLLISION_FLAG_KINEMATIC = 0x2;\nthis.COLLISION_FLAG_GHOST_OBJECT = 0x4;\n\nthis.COLLISION_FLAG_HAS_CALLBACK = 0x200;\n\n// Collision Status\nthis.COLLISION_STATUS_ENTER = 1;\nthis.COLLISION_STATUS_STAY = 2;\nthis.COLLISION_STATUS_LEAVE = 3;\n"}),define("qtek-physics/AmmoEngineWorker.js",[],function(){return"'use strict';\n\n// TODO\n// Memory leak\n\n/********************************************\n            Global Objects\n ********************************************/\n\nfunction PhysicsObject(collisionObject, transform) {\n\n    this.__idx__ = 0;\n\n    this.collisionObject = collisionObject || null;\n    this.transform = transform || null;\n\n    this.collisionStatus = [];\n\n    this.isGhostObject = false;\n    this.hasCallback = false;\n}\n\nvar g_objectsList = [];\nvar g_shapes = {};\n    \n// Map to store the ammo objects which key is the ptr of body\nvar g_ammoPtrIdxMap = {};\n\n// World objects\nvar g_dispatcher = null;\nvar g_world = null;\nvar g_ghostPairCallback = null;\n\n/********************************************\n            Buffer Object\n ********************************************/\n\n function g_Buffer() {\n\n    this.array = [];\n    this.offset = 0;\n}\n\ng_Buffer.prototype = {\n\n    constructor : g_Buffer,\n    \n    packScalar : function(scalar) {\n        this.array[this.offset++] = scalar;\n    },\n\n    packVector2 : function(vector) {\n        this.array[this.offset++] = vector.getX();\n        this.array[this.offset++] = vector.getY();\n    },\n\n    packVector3 : function(vector) {\n        this.array[this.offset++] = vector.getX();\n        this.array[this.offset++] = vector.getY();\n        this.array[this.offset++] = vector.getZ();\n    },\n\n    packVector4 : function(vector) {\n        this.array[this.offset++] = vector.getX();\n        this.array[this.offset++] = vector.getY();\n        this.array[this.offset++] = vector.getZ();\n        this.array[this.offset++] = vector.getW();\n    },\n\n    packMatrix3x3 : function(m3x3) {\n        this.packVector3(m3x3.getColumn(0));\n        this.packVector3(m3x3.getColumn(1));\n        this.packVector3(m3x3.getColumn(2));\n    },\n\n    toFloat32Array : function() {\n        this.array.length = this.offset;\n        return new Float32Array(this.array);\n    }\n}\n\nvar g_stepBuffer = new g_Buffer();\nvar g_inertiaTensorBuffer = new g_Buffer();\nvar g_rayTestBuffer = new g_Buffer();\n\n\n/********************************************\n            Message Dispatcher\n ********************************************/\n\nonmessage = function(e) {\n    // Init the word\n    if (e.data.__init__) {\n        cmd_InitAmmo(e.data.ammoUrl, e.data.gravity);\n        return;\n    }\n\n    var buffer = new Float32Array(e.data);\n    \n    var nChunk = buffer[0];\n\n    var offset = 1;\n    var haveStep = false;\n    var stepTime, maxSubSteps, fixedTimeStep;\n    var addedCollisonObjects = [];\n    for (var i = 0; i < nChunk; i++) {\n        var cmdType = buffer[offset++];\n        // Dispatch\n        switch(cmdType) {\n            case CMD_ADD_COLLIDER:\n                offset = cmd_AddCollisionObject(buffer, offset, addedCollisonObjects);\n                break;\n            case CMD_REMOVE_COLLIDER:\n                offset = cmd_RemoveCollisionObject(buffer, offset);\n                break;\n            case CMD_MOD_COLLIDER:\n                offset = cmd_ModCollisionObject(buffer, offset);\n                break;\n            case CMD_STEP:\n                haveStep = true;\n                stepTime = buffer[offset++];\n                maxSubSteps = buffer[offset++];\n                fixedTimeStep = buffer[offset++];\n                break;\n            case CMD_RAYTEST_ALL:\n            case CMD_RAYTEST_CLOSEST:\n                offset = cmd_Raytest(buffer, offset, cmdType === CMD_RAYTEST_CLOSEST);\n                break;\n            default:\n        }\n    }\n\n    // Sync back inertia tensor\n    // Calculating torque needs this stuff\n    if (addedCollisonObjects.length > 0) { \n        g_inertiaTensorBuffer.offset = 0;\n        g_inertiaTensorBuffer.packScalar(1); // nChunk\n        g_inertiaTensorBuffer.packScalar(CMD_SYNC_INERTIA_TENSOR);   // Command\n        g_inertiaTensorBuffer.packScalar(0); // nBody\n        var nBody = 0;\n        for (var i = 0; i < addedCollisonObjects.length; i++) {\n            var co = addedCollisonObjects[i];\n            var body = co.collisionObject;\n            if (body.getInvInertiaTensorWorld) {\n                var m3x3 = body.getInvInertiaTensorWorld();\n                g_inertiaTensorBuffer.packScalar(co.__idx__);\n                g_inertiaTensorBuffer.packMatrix3x3(m3x3);\n                nBody++;\n            }\n        }\n        g_inertiaTensorBuffer.array[2] = nBody;\n        var array = g_inertiaTensorBuffer.toFloat32Array();\n        postMessage(array.buffer, [array.buffer]);\n    }\n\n    // Lazy execute\n    if (haveStep) {\n        g_stepBuffer.offset = 0;\n        cmd_Step(stepTime, maxSubSteps, fixedTimeStep);\n    }\n}\n\n/********************************************\n            Util Functions\n ********************************************/\n\nfunction _unPackVector3(buffer, offset) {\n    return new Ammo.btVector3(buffer[offset++], buffer[offset++], buffer[offset]);\n}\n\nfunction _setVector3(vec, buffer, offset) {\n    vec.setValue(buffer[offset++], buffer[offset++], buffer[offset++]);\n    return offset;\n}\n\nfunction _setVector4(vec, buffer, offset) {\n    vec.setValue(buffer[offset++], buffer[offset++], buffer[offset++], buffer[offset++]);\n    return offset;\n}\n\nfunction _unPackShape(buffer, offset) {\n    // Shape\n    var shapeId = buffer[offset++];\n    var shapeType = buffer[offset++];\n    var shape = g_shapes[shapeId];\n    var isCreate;\n    if (!shape) {\n        isCreate = true;\n        switch(shapeType) {\n            case SHAPE_SPHERE:\n                shape = new Ammo.btSphereShape(buffer[offset++]);\n                break;\n            case SHAPE_BOX:\n                shape = new Ammo.btBoxShape(_unPackVector3(buffer, offset));\n                offset += 3;\n                break;\n            case SHAPE_CYLINDER:\n                shape = new Ammo.btCylinderShape(_unPackVector3(buffer, offset));\n                offset += 3;\n                break;\n            case SHAPE_CONE:\n                shape = new Ammo.btConeShape(buffer[offset++], buffer[offset++]);\n                break;\n            case SHAPE_CAPSULE:\n                shape = new Ammo.btCapsuleShape(buffer[offset++], buffer[offset++]);\n                break;\n            case SHAPE_CONVEX_TRIANGLE_MESH:\n            case SHAPE_BVH_TRIANGLE_MESH:\n                var nTriangles = buffer[offset++];\n                var nVertices = buffer[offset++];\n                var indexStride = 3 * 4;\n                var vertexStride = 3 * 4;\n                \n                var triangleIndices = buffer.subarray(offset, offset + nTriangles * 3);\n                offset += nTriangles * 3;\n                var indicesPtr = Ammo.allocate(indexStride * nTriangles, 'i32', Ammo.ALLOC_NORMAL);\n                for (var i = 0; i < triangleIndices.length; i++) {\n                    Ammo.setValue(indicesPtr + i * 4, triangleIndices[i], 'i32');\n                }\n\n                var vertices = buffer.subarray(offset, offset + nVertices * 3);\n                offset += nVertices * 3;\n                var verticesPtr = Ammo.allocate(vertexStride * nVertices, 'float', Ammo.ALLOC_NORMAL);\n                for (var i = 0; i < vertices.length; i++) {\n                    Ammo.setValue(verticesPtr + i * 4, vertices[i], 'float');\n                }\n\n                var indexVertexArray = new Ammo.btTriangleIndexVertexArray(nTriangles, indicesPtr, indexStride, nVertices, verticesPtr, vertexStride);\n                // TODO Cal AABB ?\n                if (shapeType === SHAPE_CONVEX_TRIANGLE_MESH) {\n                    shape = new Ammo.btConvexTriangleMeshShape(indexVertexArray, true);\n                } else {\n                    shape = new Ammo.btBvhTriangleMeshShape(indexVertexArray, true, true);\n                }\n                break;\n            case SHAPE_CONVEX_HULL:\n                var nPoints = buffer[offset++];\n                var stride = 3 * 4;\n                var points = buffer.subarray(offset, offset + nPoints * 3);\n                offset += nPoints * 3;\n                var pointsPtr = Ammo.allocate(stride * nPoints, 'float', Ammo.ALLOC_NORMAL);\n                for (var i = 0; i < points.length; i++) {\n                    Ammo.setValue(pointsPtr + i * 4, points[i], 'float');\n                }\n\n                shape = new Ammo.btConvexHullShape(pointsPtr, nPoints, stride);\n                break;\n            case SHAPE_STATIC_PLANE:\n                var normal = _unPackVector3(buffer, offset);\n                offset+=3;\n                shape = new Ammo.btStaticPlaneShape(normal, buffer[offset++]);\n                break;\n            case SHAPE_COMPOUND:\n                var nChildren = buffer[offset++];\n                var shape = new Ammo.btCompoundShape();\n                for (var i = 0; i < nChildren; i++) {\n                    var origin = new Ammo.btVector3(buffer[offset++], buffer[offset++], buffer[offset++]);\n                    var rotation = new Ammo.btQuaternion(buffer[offset++], buffer[offset++], buffer[offset++], buffer[offset++]);\n                    var res = _unPackShape(buffer, offset);\n                    var childShape = res[0];\n                    offset = res[1];\n                    var transform = new Ammo.btTransform(rotation, origin);\n                    shape.addChildShape(transform, childShape);\n                }\n                break;\n            default:\n                throw new Error('Unknown type ' + shapeType);\n                break;\n        }\n\n        g_shapes[shapeId] = shape;\n    } else {\n        isCreate = false;\n        switch(shapeType) {\n            case SHAPE_SPHERE:\n                offset++;\n                break;\n            case SHAPE_BOX:\n            case SHAPE_CYLINDER:\n                offset += 3;\n                break;\n            case SHAPE_CONE:\n            case SHAPE_CAPSULE:\n                offset += 2;\n                break;\n            case SHAPE_CONVEX_TRIANGLE_MESH:\n            case SHAPE_BVH_TRIANGLE_MESH:\n                var nTriangles = buffer[offset++];\n                var nVertices = buffer[offset++];\n                offset += nTriangles * 3 + nVertices * 3;\n                break;\n            case SHAPE_CONVEX_HULL:\n                var nPoints = buffer[offset++];\n                offset += nPoints * 3;\n                break;\n            case SHAPE_STATIC_PLANE:\n                offset += 4;\n                break;\n            case SHAPE_COMPOUND:\n                // TODO when children are changed\n                var nChildren = buffer[offset++];\n                for (var i = 0; i < nChildren; i++) {\n                    offset += 7;\n                    var res = _unPackShape(buffer, offset);\n                    var childShape = res[0];\n                    offset = res[1];\n                }\n                break;\n            default:\n                throw new Error('Unknown type ' + shapeType);\n                break;\n        }\n    }\n\n    return [shape, offset, isCreate];\n}\n\n/********************************************\n                COMMANDS\n ********************************************/\n\nfunction cmd_InitAmmo(ammoUrl, gravity) {\n    importScripts(ammoUrl);\n    if (!gravity) {\n        gravity = [0, -10, 0];\n    }\n\n    var broadphase = new Ammo.btDbvtBroadphase();\n    var collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();\n    g_dispatcher = new Ammo.btCollisionDispatcher(collisionConfiguration);\n    var solver = new Ammo.btSequentialImpulseConstraintSolver();\n    g_world = new Ammo.btDiscreteDynamicsWorld(g_dispatcher, broadphase, solver, collisionConfiguration);\n    g_world.setGravity(new Ammo.btVector3(gravity[0], gravity[1], gravity[2]));\n\n    postMessage({\n        __init__ : true\n    });\n}\n\nfunction cmd_AddCollisionObject(buffer, offset, out) {\n    var idx = buffer[offset++];\n    var bitMask = buffer[offset++];\n\n    var collisionFlags = buffer[offset++];\n    var isGhostObject = COLLISION_FLAG_GHOST_OBJECT & collisionFlags;\n    var hasCallback = COLLISION_FLAG_HAS_CALLBACK & collisionFlags;\n\n    var group = buffer[offset++];\n    var collisionMask = buffer[offset++];\n\n    if (MOTION_STATE_MOD_BIT & bitMask) {\n        var origin = new Ammo.btVector3(buffer[offset++], buffer[offset++], buffer[offset++]);\n        var quat = new Ammo.btQuaternion(buffer[offset++], buffer[offset++], buffer[offset++], buffer[offset++]);\n        var transform = new Ammo.btTransform(quat, origin);\n    } else {\n        var transform = new Ammo.btTransform();\n    }\n\n    if (!isGhostObject) {\n        var motionState = new Ammo.btDefaultMotionState(transform);\n\n        if (RIGID_BODY_PROP_MOD_BIT.linearVelocity & bitMask) {\n            var linearVelocity = _unPackVector3(buffer, offset);\n            offset += 3;\n        }\n        if (RIGID_BODY_PROP_MOD_BIT.angularVelocity & bitMask) {\n            var angularVelocity = _unPackVector3(buffer, offset);\n            offset += 3;\n        }\n        if (RIGID_BODY_PROP_MOD_BIT.linearFactor & bitMask) {\n            var linearFactor = _unPackVector3(buffer, offset);\n            offset += 3;\n        }\n        if (RIGID_BODY_PROP_MOD_BIT.angularFactor & bitMask) {\n            var angularFactor = _unPackVector3(buffer, offset);\n            offset += 3;\n        }\n        if (RIGID_BODY_PROP_MOD_BIT.centerOfMass & bitMask) {\n            // TODO\n            // centerOfMass = _unPackVector3(buffer, offset);\n            offset += 3;\n        }\n        if (RIGID_BODY_PROP_MOD_BIT.localInertia & bitMask) {\n            var localInertia = _unPackVector3(buffer, offset);\n            offset += 3;\n        }\n        if (RIGID_BODY_PROP_MOD_BIT.massAndDamping & bitMask) {\n            var massAndDamping = _unPackVector3(buffer, offset);\n            offset += 3;\n        }\n        if (RIGID_BODY_PROP_MOD_BIT.totalForce & bitMask) {\n            var totalForce = _unPackVector3(buffer, offset);\n            offset += 3;\n        }\n        if (RIGID_BODY_PROP_MOD_BIT.totalTorque & bitMask) {\n            var totalTorque = _unPackVector3(buffer, offset);\n            offset += 3;\n        }\n    }\n\n    var res = _unPackShape(buffer, offset);\n    var shape = res[0];\n    offset = res[1];\n\n    if (massAndDamping) {\n        var mass = massAndDamping.getX();\n    } else {\n        var mass = 0;\n    }\n\n    var physicsObject;\n    if (!isGhostObject) {\n        if (!localInertia) {\n            localInertia = new Ammo.btVector3(0, 0, 0);\n            if (mass !== 0) { // Is dynamic\n                shape.calculateLocalInertia(mass, localInertia);\n            }\n        }\n        var rigidBodyInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, shape, localInertia);\n        var rigidBody = new Ammo.btRigidBody(rigidBodyInfo);\n\n        rigidBody.setCollisionFlags(collisionFlags);\n\n        linearVelocity && rigidBody.setLinearVelocity(linearVelocity);\n        angularVelocity && rigidBody.setAngularVelocity(angularVelocity);\n        linearFactor && rigidBody.setLinearFactor(linearFactor);\n        angularFactor && rigidBody.setAngularFactor(angularFactor);\n        if (massAndDamping) {\n            rigidBody.setDamping(massAndDamping.getY(), massAndDamping.getZ());\n        }\n        totalForce && rigidBody.applyCentralForce(totalForce);\n        totalTorque && rigidBody.applyTorque(totalTorque);\n\n        rigidBody.setFriction(buffer[offset++]);\n        rigidBody.setRestitution(buffer[offset++]);\n\n        physicsObject = new PhysicsObject(rigidBody, transform);\n        physicsObject.hasCallback = hasCallback;\n        g_objectsList[idx] = physicsObject;\n        g_ammoPtrIdxMap[rigidBody.ptr] = idx;\n        // TODO\n        // g_world.addRigidBody(rigidBody, group, collisionMask);\n        g_world.addRigidBody(rigidBody);\n    } else {\n        // TODO What's the difference of Pair Caching Ghost Object ?\n        var ghostObject = new Ammo.btPairCachingGhostObject();\n        ghostObject.setCollisionShape(shape);\n        ghostObject.setWorldTransform(transform);\n\n        physicsObject = new PhysicsObject(ghostObject, transform);\n        physicsObject.hasCallback = hasCallback;\n        physicsObject.isGhostObject = true;\n        g_objectsList[idx] = physicsObject;\n        // TODO\n        // g_world.addCollisionObject(ghostObject, group, collisionMask);\n        g_world.addCollisionObject(ghostObject);\n\n        g_ammoPtrIdxMap[ghostObject.ptr] = idx;\n        // TODO\n        if (!g_ghostPairCallback) {\n            g_ghostPairCallback = new Ammo.btGhostPairCallback();\n            g_world.getPairCache().setInternalGhostPairCallback(g_ghostPairCallback);\n        }\n    }\n\n    physicsObject.__idx__ = idx;\n    out.push(physicsObject);\n\n    return offset;\n}\n\n\nfunction cmd_RemoveCollisionObject(buffer, offset) {\n    var idx = buffer[offset++];\n    var obj = g_objectsList[idx];\n    g_objectsList[idx] = null;\n    if (obj.isGhostObject) {\n        g_world.removeCollisionObject(obj.collisionObject);\n    } else {\n        g_world.removeRigidBody(obj.collisionObject);\n    }\n    // TODO destroy ?\n    Ammo.destroy(obj.collisionObject);\n    return offset;\n}\n\nfunction cmd_ModCollisionObject(buffer, offset) {\n    var idx = buffer[offset++];\n    var bitMask = buffer[offset++];\n\n    var obj = g_objectsList[idx];\n    var collisionObject = obj.collisionObject;\n    var bodyNeedsActive = false;\n\n    if (COLLISION_FLAG_MOD_BIT & bitMask) {\n        var collisionFlags = buffer[offset++];\n        collisionObject.setCollisionFlags(collisionFlags);\n\n        obj.hasCallback = collisionFlags & COLLISION_FLAG_HAS_CALLBACK;\n        obj.isGhostObject = collisionFlags & COLLISION_FLAG_GHOST_OBJECT;\n    }\n    if (MOTION_STATE_MOD_BIT & bitMask) {\n        var motionState = collisionObject.getMotionState();\n        var transform = obj.transform;\n        motionState.getWorldTransform(transform);\n        offset = _setVector3(transform.getOrigin(), buffer, offset);\n        offset = _setVector4(transform.getRotation(), buffer, offset);\n        motionState.setWorldTransform(transform);\n    }\n\n    if (RIGID_BODY_PROP_MOD_BIT.linearVelocity & bitMask) {\n        offset = _setVector3(collisionObject.getLinearVelocity(), buffer, offset);\n        bodyNeedsActive = true;\n    }\n    if (RIGID_BODY_PROP_MOD_BIT.angularVelocity & bitMask) {\n        offset = _setVector3(collisionObject.getAngularVelocity(), buffer, offset);\n        bodyNeedsActive = true;\n    }\n    if (RIGID_BODY_PROP_MOD_BIT.linearFactor & bitMask) {\n        offset = _setVector3(collisionObject.getLinearFactor(), buffer, offset);\n    }\n    if (RIGID_BODY_PROP_MOD_BIT.angularFactor & bitMask) {\n        offset = _setVector3(collisionObject.getAngularFactor(), buffer, offset);\n    }\n    if (RIGID_BODY_PROP_MOD_BIT.centerOfMass & bitMask) {\n        // TODO\n        offset += 3;\n    }\n    if (RIGID_BODY_PROP_MOD_BIT.localInertia & bitMask) {\n        // TODO\n        offset += 3;\n    }\n    if (RIGID_BODY_PROP_MOD_BIT.massAndDamping & bitMask) {\n        // TODO MASS\n        var mass = buffer[offset++];\n        collisionObject.setDamping(buffer[offset++], buffer[offset++]);\n    }\n    if (RIGID_BODY_PROP_MOD_BIT.totalForce & bitMask) {\n        offset = _setVector3(collisionObject.getTotalForce(), buffer, offset);\n        bodyNeedsActive = true;\n    }\n    if (RIGID_BODY_PROP_MOD_BIT.totalTorque & bitMask) {\n        offset = _setVector3(collisionObject.getTotalTorque(), buffer, offset);\n        bodyNeedsActive = true;\n    }\n\n    if (bodyNeedsActive) {\n        collisionObject.activate();\n    }\n\n    // Shape\n    if (SHAPE_MOD_BIT & bitMask) {\n        // TODO\n        // destroy child shapes of compound shape\n        var shapeId = buffer[offset];\n        var shape = g_shapes[shapeId];\n        Ammo.destroy(shape);\n        g_shapes[shapeId] = null;\n\n        var res = _unPackShape(buffer, offset);\n        var shape = res[0];\n        offset = res[1];\n        collisionObject.setCollisionShape(shape);\n    }\n    if (MATERIAL_MOD_BIT & bitMask) {\n        collisionObject.setFriction(buffer[offset++]);\n        collisionObject.setRestitution(buffer[offset++]);\n    }\n \n    return offset;\n}\n\nfunction cmd_Step(timeStep, maxSubSteps, fixedTimeStep) {\n\n    var startTime = new Date().getTime();\n    g_world.stepSimulation(timeStep, maxSubSteps, fixedTimeStep);\n    var stepTime = new Date().getTime() - startTime;\n\n    var nChunk = 3;\n    g_stepBuffer.packScalar(nChunk);\n\n    // Sync Motion State\n    g_stepBuffer.packScalar(CMD_SYNC_MOTION_STATE);\n    var nObjects = 0;\n    var nObjectsOffset = g_stepBuffer.offset;\n    g_stepBuffer.packScalar(nObjects);\n\n    for (var i = 0; i < g_objectsList.length; i++) {\n        var obj = g_objectsList[i];\n        if (!obj) {\n            continue;\n        }\n        var collisionObject = obj.collisionObject;\n        if (collisionObject.isStaticOrKinematicObject()) {\n            continue;\n        }\n        // Idx\n        g_stepBuffer.packScalar(i);\n        var motionState = collisionObject.getMotionState();\n        motionState.getWorldTransform(obj.transform);\n\n        g_stepBuffer.packVector3(obj.transform.getOrigin());\n        g_stepBuffer.packVector4(obj.transform.getRotation());\n        nObjects++;\n    }\n    g_stepBuffer.array[nObjectsOffset] = nObjects;\n\n    // Return step time\n    g_stepBuffer.packScalar(CMD_STEP_TIME);\n    g_stepBuffer.packScalar(stepTime);\n\n    // Tick callback\n    _tickCallback(g_world);\n\n    var array = g_stepBuffer.toFloat32Array();\n\n    postMessage(array.buffer, [array.buffer]);\n}\n\n// nmanifolds - [idxA - idxB - ncontacts - [pA - pB - normal]... ]...\nfunction _tickCallback(world) {\n\n    g_stepBuffer.packScalar(CMD_COLLISION_CALLBACK);\n\n    var nManifolds = g_dispatcher.getNumManifolds();\n    var nCollision = 0;\n    var tickCmdOffset = g_stepBuffer.offset;\n    g_stepBuffer.packScalar(0);  //nManifolds place holder\n\n    for (var i = 0; i < nManifolds; i++) {\n        var contactManifold = g_dispatcher.getManifoldByIndexInternal(i);\n        var obAPtr = contactManifold.getBody0();\n        var obBPtr = contactManifold.getBody1();\n\n        var nContacts = contactManifold.getNumContacts();\n\n        if (nContacts > 0) {\n            var obAIdx = g_ammoPtrIdxMap[obAPtr];\n            var obBIdx = g_ammoPtrIdxMap[obBPtr];\n\n            var obA = g_objectsList[obAIdx];\n            var obB = g_objectsList[obBIdx];\n\n            if (obA.hasCallback || obB.hasCallback) {\n                var chunkStartOffset = g_stepBuffer.offset;\n                if (_packContactManifold(contactManifold, chunkStartOffset, obAIdx, obBIdx)) {\n                    nCollision++;\n                }\n            }\n        }\n    }\n\n    g_stepBuffer.array[tickCmdOffset] = nCollision;\n}\n\nfunction _packContactManifold(contactManifold, offset, obAIdx, obBIdx) {\n    // place holder for idxA, idxB, nContacts\n    g_stepBuffer.offset += 3;\n    var nActualContacts = 0;\n    var nContacts = contactManifold.getNumContacts();\n    for (var j = 0; j < nContacts; j++) {\n        var cp = contactManifold.getContactPoint(j);\n\n        if (cp.getDistance() <= 0) {\n            var pA = cp.getPositionWorldOnA();\n            var pB = cp.getPositionWorldOnB();\n            var normal = cp.get_m_normalWorldOnB();\n\n            g_stepBuffer.packVector3(pA);\n            g_stepBuffer.packVector3(pB);\n            g_stepBuffer.packVector3(normal);\n            nActualContacts++;\n        }\n    }\n\n    if (nActualContacts > 0) {\n        g_stepBuffer.array[offset] = obAIdx;\n        g_stepBuffer.array[offset+1] = obBIdx;\n        g_stepBuffer.array[offset+2] = nActualContacts;\n\n        return true;\n    } else {\n        g_stepBuffer.offset -= 3;\n        return false;\n    }\n}\n\nvar rayStart = null;\nvar rayEnd = null;\nfunction cmd_Raytest(buffer, offset, isClosest) {\n    if (!rayStart) {\n        rayStart = new Ammo.btVector3();\n        rayEnd = new Ammo.btVector3();\n    }\n    var cbIdx = buffer[offset++];\n    rayStart.setValue(buffer[offset++], buffer[offset++], buffer[offset++]);\n    rayEnd.setValue(buffer[offset++], buffer[offset++], buffer[offset++]);\n\n    g_rayTestBuffer.offset = 0;\n    g_rayTestBuffer.packScalar(1);\n    g_rayTestBuffer.packScalar(isClosest ? CMD_RAYTEST_CLOSEST : CMD_RAYTEST_ALL);\n    g_rayTestBuffer.packScalar(cbIdx);\n\n    if (isClosest) {\n        var callback = new Module.ClosestRayResultCallback(rayStart, rayEnd);\n        var colliderIdx = -1;\n        g_world.rayTest(rayStart, rayEnd, callback);\n        if (callback.hasHit()) {\n            var co = callback.get_m_collisionObject();\n            colliderIdx = g_ammoPtrIdxMap[co.ptr];\n            g_rayTestBuffer.packScalar(colliderIdx);\n            // hit point\n            g_rayTestBuffer.packVector3(callback.get_m_hitPointWorld());\n            // hit normal\n            g_rayTestBuffer.packVector3(callback.get_m_hitNormalWorld());\n        }\n\n        var array = g_rayTestBuffer.toFloat32Array();\n        postMessage(array.buffer, [array.buffer]);\n    } else {\n        var callback = new Module.AllHitsRayResultCallback(rayStart, rayEnd);\n        g_world.rayTest(rayStart, rayEnd, callback);\n        if (callback.hasHit()) {\n            // TODO\n        }\n    }\n\n    return offset;\n}"}),define("qtek-physics/Shape",["require","qtek/core/Base"],function(a){var b=a("qtek/core/Base"),c=b.derive({},{dirty:function(){this._dirty=!0}});return c}),define("qtek-physics/shape/Box",["require","../Shape","qtek/math/Vector3"],function(a){var b=a("../Shape"),c=a("qtek/math/Vector3"),d=b.derive({halfExtents:null},function(){this.halfExtents||(this.halfExtents=new c(1,1,1))});return Object.defineProperty(d.prototype,"width",{get:function(){return 2*this.halfExtents._array[0]},set:function(a){this.halfExtents._array[0]=a/2,this.halfExtents._dirty=!0}}),Object.defineProperty(d.prototype,"height",{get:function(){return 2*this.halfExtents._array[1]},set:function(a){this.halfExtents._array[1]=a/2,this.halfExtents._dirty=!0}}),Object.defineProperty(d.prototype,"depth",{get:function(){return 2*this.halfExtents._array[2]},set:function(a){this.halfExtents._array[2]=a/2,this.halfExtents._dirty=!0}}),d}),define("qtek-physics/shape/Capsule",["require","../Shape","qtek/math/Vector3"],function(a){var b=a("../Shape"),c=(a("qtek/math/Vector3"),b.derive({_radius:1,_height:1,_dirty:!0}));return Object.defineProperty(c.prototype,"radius",{get:function(){return this._radius},set:function(a){this._radius=a,this._dirty=!0}}),Object.defineProperty(c.prototype,"height",{get:function(){return this._height},set:function(a){this._height=a,this._dirty=!0}}),Object.defineProperty(c.prototype,"halfHeight",{get:function(){return this._height/2},set:function(a){this._height=2*a,this._dirty=!0}}),c}),define("qtek-physics/shape/Cone",["require","../Shape","qtek/math/Vector3"],function(a){var b=a("../Shape"),c=(a("qtek/math/Vector3"),b.derive({_radius:1,_height:1,_dirty:!0}));return Object.defineProperty(c.prototype,"radius",{get:function(){return this._radius
},set:function(a){this._radius=a,this._dirty=!0}}),Object.defineProperty(c.prototype,"height",{get:function(){return this._height},set:function(a){this._height=a,this._dirty=!0}}),c}),define("qtek-physics/shape/Cylinder",["require","../Shape","qtek/math/Vector3"],function(a){var b=a("../Shape"),c=a("qtek/math/Vector3"),d=b.derive({halfExtents:null,_upAxis:1,_dirty:!0,_radiusIdx:0,_heightIdx:1},function(){this.halfExtents||(this.halfExtents=new c(1,1,1))});return Object.defineProperty(d.prototype,"radius",{get:function(){return this.halfExtents._array[this._radiusIdx]},set:function(a){this.halfExtents._array[this._radiusIdx]=a,this.halfExtents._dirty=!0}}),Object.defineProperty(d.prototype,"height",{get:function(){return 2*this.halfExtents._array[this._heightIdx]},set:function(a){this.halfExtents._array[this._heightIdx]=a/2,this.halfExtents._dirty=!0}}),Object.defineProperty(d.prototype,"upAxis",{set:function(a){switch(a){case 0:this._radiusIdx=1,this._heightIdx=0;break;case 2:this._radiusIdx=0,this._heightIdx=2;break;default:this._radiusIdx=0,this._heightIdx=1}this._upAxis=a,this._dirty=!0},get:function(){return this._upAxis}}),d}),define("qtek-physics/shape/Sphere",["require","../Shape"],function(a){var b=a("../Shape"),c=b.derive({_radius:1,_dirty:!0});return Object.defineProperty(c.prototype,"radius",{get:function(){return this._radius},set:function(a){this._radius=a,this._dirty=!0}}),c}),define("qtek-physics/shape/StaticPlane",["require","../Shape","qtek/math/Plane"],function(a){var b=a("../Shape"),c=a("qtek/math/Plane"),d=b.derive({_dirty:!1},function(){this.plane||(this.plane=new c,this.plane.normal.set(0,0,1),this.plane.distance=0)});return d}),define("qtek-physics/shape/ConvexTriangleMesh",["require","../Shape"],function(a){var b=a("../Shape"),c=b.derive({geometry:null});return c}),define("qtek-physics/shape/BvhTriangleMesh",["require","../Shape"],function(a){var b=a("../Shape"),c=b.derive({geometry:null});return c}),define("qtek-physics/shape/ConvexHull",["require","../Shape"],function(a){var b=a("../Shape"),c=b.derive({geometry:null});return c}),define("qtek-physics/shape/Compound",["require","../Shape","qtek/math/Vector3","qtek/math/Quaternion"],function(a){var b=a("../Shape"),c=a("qtek/math/Vector3"),d=a("qtek/math/Quaternion"),e=function(a,b,e){this.shape=a,this.position=b||new c,this.rotation=e||new d},f=b.derive({_dirty:!1},function(){this._children=[]},{addChildShape:function(a,b,c){this.removeChildShape(a);var d=new e(a,b,c);return this._children.push(d),this._dirty=!0,d},removeChildShape:function(a){for(var b=0;b<this._children.length;b++)if(this._children[b].shape===a)return this._children.splice(b,1),void(this._dirty=!0)},getChildShape:function(a){for(var b=0;b<this._children.length;b++)if(this._children[b].shape===a)return this._children[b]},getChildShapeAt:function(a){return this._children[a]}});return f}),define("qtek-physics/Pool",["require"],function(){function a(){this._size=0,this._data=[],this._empties=[]}return a.prototype.add=function(a){var b;return this._empties.length>0?(b=this._empties.pop(),this._data[b]=a):(b=this._data.length,this._data.push(a)),this._size++,b},a.prototype.remove=function(a){var b=this._data.indexOf(a);this.removeAt(b),this._size--},a.prototype.removeAt=function(a){this._data[a]=null,this._empties.push(a)},a.prototype.removeAll=function(){this._data=[],this._empties=[],this._size=0},a.prototype.getAt=function(a){return this._data[a]},a.prototype.getIndex=function(a){return this._data.indexOf(a)},a.prototype.getAll=function(){return this._data},a.prototype.refresh=function(){for(var a=[],b=0;b<this._data.length;b++)null!==this._data[b]&&a.push(this._data[b]);this._data=a},a.prototype.each=function(a,b){for(var c=0;c<this._data.length;c++)null!==this._data[c]&&a.call(b||this,this._data[c],c);this._data=newData},a}),define("qtek-physics/Engine",["require","qtek/core/Base","qtek/core/util","./AmmoEngineConfig.js","./AmmoEngineWorker.js","./shape/Box","./shape/Capsule","./shape/Cone","./shape/Cylinder","./shape/Sphere","./shape/StaticPlane","./shape/ConvexTriangleMesh","./shape/BvhTriangleMesh","./shape/ConvexHull","./shape/Compound","./Buffer","./Pool","./ContactPoint","qtek/math/Vector3"],function(a){var b=a("qtek/core/Base"),c=a("qtek/core/util"),d=a("./AmmoEngineConfig.js"),e=a("./AmmoEngineWorker.js"),f=[d,e].join("\n"),g=new Blob([f]);f=null,e=null;var h=a("./shape/Box"),i=a("./shape/Capsule"),j=a("./shape/Cone"),k=a("./shape/Cylinder"),l=a("./shape/Sphere"),m=a("./shape/StaticPlane"),n=a("./shape/ConvexTriangleMesh"),o=a("./shape/BvhTriangleMesh"),p=a("./shape/ConvexHull"),q=a("./shape/Compound"),r=a("./Buffer"),s=a("./Pool"),t=a("./ContactPoint"),u=a("qtek/math/Vector3"),v=new Function(d),w=new v,x=b.derive(function(){return{ammoUrl:"",gravity:new u(0,-10,0),maxSubSteps:3,fixedTimeStep:1/60,_stepTime:0,_isWorkerInited:!1,_isWorkerFree:!0,_accumalatedTime:0,_colliders:new s,_collidersToAdd:[],_collidersToRemove:[],_contacts:[],_callbacks:new s,_cmdBuffer:new r,_rayTestBuffer:new r}},{init:function(){var a=window.URL.createObjectURL(g);this._engineWorker=new Worker(a);var b=this.ammoUrl;0!=b.indexOf("http")&&(b=c.relative2absolute(this.ammoUrl,window.location.href.split("/").slice(0,-1).join("/"))),this._engineWorker.postMessage({__init__:!0,ammoUrl:b,gravity:[this.gravity.x,this.gravity.y,this.gravity.z]});var d=this;this._engineWorker.onmessage=function(a){if(a.data.__init__)return void(d._isWorkerInited=!0);for(var b=new Float32Array(a.data),c=b[0],e=1,f=0;c>f;f++){var g=b[e++];switch(g){case w.CMD_SYNC_MOTION_STATE:e=d._syncMotionState(b,e);break;case w.CMD_STEP_TIME:d._stepTime=b[e++];break;case w.CMD_COLLISION_CALLBACK:e=d._dispatchCollisionCallback(b,e);break;case w.CMD_SYNC_INERTIA_TENSOR:e=d._syncInertiaTensor(b,e);break;case w.CMD_RAYTEST_ALL:case w.CMD_RAYTEST_CLOSEST:e=d._rayTestCallback(b,e,g===w.CMD_RAYTEST_CLOSEST)}}d._isWorkerFree=!0,d.trigger("afterstep")}},step:function(a){if(this._isWorkerInited){if(!this._isWorkerFree)return void(this._accumalatedTime+=a);this._accumalatedTime=a;var b=0;this._cmdBuffer.setOffset(0),this._cmdBuffer.packScalar(0),b+=this._doModCollider(),b+=this._doRemoveCollider(),b+=this._doAddCollider(),this._cmdBuffer.packValues(w.CMD_STEP,this._accumalatedTime,this.maxSubSteps,this.fixedTimeStep),b++,this._cmdBuffer.set(0,b);var c=this._cmdBuffer.toFloat32Array();this._engineWorker.postMessage(c.buffer,[c.buffer]);for(var d=this._colliders.getAll(),e=0;e<d.length;e++){var f=d[e];if(null!==f&&!(f.isStatic||f.isKinematic||f.isGhostObject)){var g=f.collisionObject;g.totalForce._array[0]=0,g.totalForce._array[1]=0,g.totalForce._array[2]=0,g.totalTorque._array[0]=0,g.totalTorque._array[1]=0,g.totalTorque._array[2]=0}}this._isWorkerFree=!1}},addCollider:function(a){this._collidersToAdd.push(a)},removeCollider:function(a){var b=this._colliders.getIndex(a);b>=0&&this._collidersToRemove.push(b)},rayTest:function(a,b,c,d){var e=this._callbacks.add(c);this._rayTestBuffer.setOffset(0),this._rayTestBuffer.packScalar(1),this._rayTestBuffer.packScalar(d||void 0===d?w.CMD_RAYTEST_CLOSEST:w.CMD_RAYTEST_ALL),this._rayTestBuffer.packScalar(e),this._rayTestBuffer.packVector3(a),this._rayTestBuffer.packVector3(b);var f=this._rayTestBuffer.toFloat32Array();this._engineWorker.postMessage(f.buffer,[f.buffer])},dispose:function(){this._colliders.removeAll(),this._callbacks.removeAll(),this._collidersToAdd=[],this._collidersToRemove=[],this._contacts=[],this._engineWorker.terminate(),this._engineWorker=null,this._isWorkerInited=!1},_rayTestCallback:function(a,b){var c=a[b++],d=this._callbacks.getAt(c),e=a[b++],f=null,g=null,h=null;if(e>=0)var f=this._colliders.getAt(e),g=new u(a[b++],a[b++],a[b++]),h=new u(a[b++],a[b++],a[b++]);return d&&d(f,g,h),this._callbacks.removeAt(c),b},_doAddCollider:function(){for(var a=0,b=0;b<this._collidersToAdd.length;b++){var c=this._collidersToAdd[b],d=this._colliders.add(c);this._cmdBuffer.packValues(w.CMD_ADD_COLLIDER,d);var e=this._cmdBuffer._offset++,f=this._packCollider(c,!0);this._cmdBuffer.set(e,f),a++}return this._collidersToAdd.length=0,a},_doRemoveCollider:function(){for(var a=0,b=0;b<this._collidersToRemove.length;b++){var c=this._collidersToRemove[b];this._colliders.removeAt(c),this._cmdBuffer.packValues(w.CMD_REMOVE_COLLIDER,c),a++}return this._collidersToRemove.length=0,a},_doModCollider:function(){for(var a=0,b=this._colliders.getAll(),c=0;c<b.length;c++){var d=b[c];if(null!==d){var e=this._cmdBuffer._offset;this._cmdBuffer._offset+=3;var f=this._packCollider(d);0!==f?(this._cmdBuffer.set(e,w.CMD_MOD_COLLIDER),this._cmdBuffer.set(e+1,c),this._cmdBuffer.set(e+2,f),a++):this._cmdBuffer._offset-=3}}return a},_packCollider:function(a,b){var c=0;if(b||a._dirty){var d=0;a.isStatic&&(d|=w.COLLISION_FLAG_STATIC),a.isKinematic&&(d|=w.COLLISION_FLAG_KINEMATIC),a.isGhostObject&&(d|=w.COLLISION_FLAG_GHOST_OBJECT),a._collisionHasCallback&&(d|=w.COLLISION_FLAG_HAS_CALLBACK),this._cmdBuffer.packScalar(d),c|=w.COLLISION_FLAG_MOD_BIT,a._dirty=!1}b&&(this._cmdBuffer.packScalar(a.group),this._cmdBuffer.packScalar(a.collisionMask)),(b||a.isKinematic)&&(this._cmdBuffer.packVector3(a.sceneNode.position),this._cmdBuffer.packVector4(a.sceneNode.rotation),c|=w.MOTION_STATE_MOD_BIT);var e=a.collisionObject;if(!a.isGhostObject)for(var f=0;f<w.RIGID_BODY_PROPS.length;f++){var g=w.RIGID_BODY_PROPS[f],h=g[0],i=e[h],j=g[1];void 0!==i&&null!==i&&(j>1?(i._dirty||b)&&(3===j?this._cmdBuffer.packVector3(i):4===j&&this._cmdBuffer.packVector4(i),c|=g[2],i._dirty=!1):console.warn("TODO"))}var k=this._packShape(e.shape,b);if(k&&(c|=w.SHAPE_MOD_BIT),!a.isGhostObject){var l=a.physicsMaterial;if(l._dirty||b){c|=w.MATERIAL_MOD_BIT;for(var f=0;f<w.MATERIAL_PROPS.length;f++){var g=w.MATERIAL_PROPS[f],h=g[0],i=l[h],j=g[1];1===j&&this._cmdBuffer.packScalar(i)}l._dirty=!1}}return c},_packShape:function(a,b){if(!(b||a.halfExtents&&a.halfExtents._dirty&&!a._dirty))return!1;if(this._cmdBuffer.packScalar(a.__GUID__),a instanceof h)this._cmdBuffer.packScalar(w.SHAPE_BOX),this._cmdBuffer.packVector3(a.halfExtents);else if(a instanceof l)this._cmdBuffer.packScalar(w.SHAPE_SPHERE),this._cmdBuffer.packScalar(a._radius);else if(a instanceof k)this._cmdBuffer.packScalar(w.SHAPE_CYLINDER),this._cmdBuffer.packVector3(a.halfExtents);else if(a instanceof j)this._cmdBuffer.packScalar(w.SHAPE_CONE),this._cmdBuffer.packScalar(a._radius),this._cmdBuffer.packScalar(a._height);else if(a instanceof i)this._cmdBuffer.packScalar(w.SHAPE_CAPSULE),this._cmdBuffer.packScalar(a._radius),this._cmdBuffer.packScalar(a._height);else if(a instanceof m)this._cmdBuffer.packScalar(w.SHAPE_STATIC_PLANE),this._cmdBuffer.packVector3(a.plane.normal),this._cmdBuffer.packScalar(a.plane.distance);else if(a instanceof n||a instanceof o){this._cmdBuffer.packScalar(a instanceof n?w.SHAPE_CONVEX_TRIANGLE_MESH:w.SHAPE_BVH_TRIANGLE_MESH);var c=a.geometry;if(this._cmdBuffer.packScalar(c.getFaceNumber()),this._cmdBuffer.packScalar(c.getVertexNumber()),c.isStatic())this._cmdBuffer.packArray(c.faces),this._cmdBuffer.packArray(c.attributes.position.value);else{for(var d=0;d<c.faces.length;d++)this._cmdBuffer.packArray(c.faces[d]);for(var d=0;d<c.attributes.position.value.length;d++)this._cmdBuffer.packArray(c.attributes.position.value[d])}}else if(a instanceof p){this._cmdBuffer.packScalar(w.SHAPE_CONVEX_HULL);var c=a.geometry;if(this._cmdBuffer.packScalar(c.getVertexNumber()),c.isStatic())this._cmdBuffer.packArray(c.attributes.position.value);else for(var d=0;d<c.attributes.position.value.length;d++)this._cmdBuffer.packArray(c.attributes.position.value[d])}else if(a instanceof q){this._cmdBuffer.packScalar(w.SHAPE_COMPOUND),this._cmdBuffer.packScalar(a._children.length);for(var d=0;d<a._children.length;d++){var e=a._children[d];this._cmdBuffer.packVector3(e.position),this._cmdBuffer.packVector4(e.rotation),this._packShape(e.shape,!0)}}return a.halfExtents&&(a.halfExtents._dirty=!1),a._dirty=!1,!0},_syncMotionState:function(a,b){for(var c=a[b++],d=0;c>d;d++){var e=a[b++],f=this._colliders.getAt(e),g=f.sceneNode;g&&(g.position.set(a[b++],a[b++],a[b++]),g.rotation.set(a[b++],a[b++],a[b++],a[b++]))}return b},_dispatchCollisionCallback:function(a,b){for(var c=a[b++],d=0;d<this._contacts.length;d++)this._contacts[d]&&(this._contacts[d].length=0);for(var d=0;c>d;d++){var e=a[b++],f=a[b++],g=this._colliders.getAt(e),h=this._colliders.getAt(f);this._contacts[e]||(this._contacts[e]=[]),this._contacts[f]||(this._contacts[f]=[]);for(var i,j,k=a[b++],l=0;k>l;l++){if(g.hasCollisionCallback()){var i=new t;i.thisPoint.set(a[b++],a[b++],a[b++]),i.otherPoint.set(a[b++],a[b++],a[b++]),i.normal.set(a[b++],a[b++],a[b++]),i.otherCollider=h,i.thisCollider=g,this._contacts[e].push(i)}else i=null;if(h.hasCollisionCallback()){var j=new t;i?(j.thisPoint.copy(i.otherPoint),j.otherPoint.copy(i.thisPoint),j.normal.copy(i.normal).negate()):(j.thisPoint.set(a[b++],a[b++],a[b++]),j.otherPoint.set(a[b++],a[b++],a[b++]),j.normal.set(a[b++],a[b++],a[b++])),j.thisCollider=h,j.otherCollider=g,this._contacts[f].push(j)}}for(var d=0;d<this._contacts.length;d++){var m=this._contacts[d];if(m&&m.length){var n=this._colliders.getAt(d);n.trigger("collision",m)}}}return b},_syncInertiaTensor:function(a,b){for(var c=a[b++],d=0;c>d;d++)for(var e=a[b++],f=this._colliders.getAt(e),g=f.collisionObject,h=g.invInertiaTensorWorld._array,i=0;9>i;i++)h[i]=a[b++];return b}});return x}),define("qtek-physics/GhostObject",["require","qtek/core/Base"],function(a){var b=a("qtek/core/Base"),c=b.derive({shape:null},{clone:function(){return new c({shape:this.shape})}});return c}),define("qtek-physics/Material",["require","qtek/core/Base"],function(a){var b=a("qtek/core/Base"),c=b.derive({_friction:.5,_bounciness:.3,_dirty:!0});return Object.defineProperty(c.prototype,"friction",{get:function(){return this._friction},set:function(a){this._friction=a,this._dirty=!0}}),Object.defineProperty(c.prototype,"bounciness",{get:function(){return this._bounciness},set:function(a){this._friction=a,this._dirty=!0}}),c}),define("qtek-physics/RigidBody",["require","qtek/core/Base","qtek/math/Vector3","qtek/math/Quaternion","glmatrix","qtek/math/Matrix3"],function(a){var b=a("qtek/core/Base"),c=a("qtek/math/Vector3"),d=(a("qtek/math/Quaternion"),a("glmatrix")),e=d.vec3,f=a("qtek/math/Matrix3"),g=b.derive(function(){return{shape:null,linearVelocity:new c,angularVelocity:new c,localInertia:null,centerOfMass:null,linearFactor:new c(1,1,1),angularFactor:new c(1,1,1),totalForce:new c(0,0,0),totalTorque:new c(0,0,0),massAndDamping:new c,invInertiaTensorWorld:new f}},{applyForce:function(){var a=new c,b=new c;return function(c,d){e.mul(b._array,c._array,this.linearFactor._array),this.totalForce.add(b),d&&(e.cross(a._array,d._array,b._array),this.applyTorque(a))}}(),applyTorque:function(){var a=new c;return function(b){e.mul(a._array,b._array,this.angularFactor._array),this.totalTorque.add(a)}}(),applyImpulse:function(){var a=new c,b=new c;return function(c,d){0!==this.mass&&(e.mul(b._array,c._array,this.linearFactor._array),this.linearVelocity.scaleAndAdd(b,1/this.mass),d&&(e.cross(a._array,d._array,b._array),this.applyTorqueImpulse(a)))}}(),applyTorqueImpulse:function(){var a=new c;return function(b){e.mul(a._array,b._array,this.angularFactor._array),e.transformMat3(this.angularVelocity._array,a._array,this.invInertiaTensorWorld._array),this.angularVelocity._dirty=!0}}(),clearForces:function(){this.totalForce.set(0,0,0),this.totalTorque.set(0,0,0)},clone:function(){var a=new g;return a.shape=this.shape,a.linearFactor.copy(this.linearFactor),a.angularFactor.copy(this.angularFactor),a.massAndDamping.copy(this.massAndDamping),a}});return Object.defineProperty(g.prototype,"mass",{get:function(){return this.massAndDamping._array[0]},set:function(a){this.massAndDamping._array[0]=a,this.massAndDamping._dirty=!0}}),Object.defineProperty(g.prototype,"linearDamping",{get:function(){return this.massAndDamping._array[1]},set:function(a){this.massAndDamping._array[1]=a,this.massAndDamping._dirty=!0}}),Object.defineProperty(g.prototype,"angularDamping",{get:function(){return this.massAndDamping._array[2]},set:function(a){this.massAndDamping._array[2]=a,this.massAndDamping._dirty=!0}}),g});